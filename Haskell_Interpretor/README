Neata Adrian 321CB

	Task a
	Pentru primul task mi-am definit ClassState-ul ca fiind numele clasei, numele clasei mostenitoare si doua map-uri ce contineau variabile si functii. Mapele aveau cheia numele variabilei/functiei, iar valoare era o lista de liste de string-uri (functiile erau retinute ca si liste de string-uri si puteau avea acelasi nume asa ca am ales valoarea o lista de liste astfel cand caut numele unei functii voi avea o lista cu toate functiile care au acel nume). Functia de initializare a unui ClassState imi creeaza clasa de baza Global. Pentru restul functiilor am facut apelurile functiilor corespunzatoare, deja definite, pentru a scoate sau pune in map ce trebuie (lookup, insert, concat, elems).
	Task b
	Pentru parsare mi-am definit eu toate functiile de care am nevoie (ar fi trebuit sa caut pe net functii predefinite, dar am uitat ca exista :o ). Mi-am definit Program-ul ca o lista de ClassState-uri, iar Instruction-ul ca tipul instructiunii care apare pe linie (declarare clasa/functie/variabila/infer) sau ca NotInstruction (daca linia e scrisa gresit si trebuie ignorata). Input-ul primit ca String este impartit pe linii si apoi transformat in liste de String-uri pentru a fi mai usor de utilizat. Pentru inceput se verifica care este primul cuvant de pe line si in functie de acesta se apeleaza parseClass/parseVar/parseFunc/parseInfer fiecare returnand o instructiune.
-parseClass se asigura ca numele clasei este valid (incepe cu o litera) si mai face cateva verificari pentru mostenire apoi creaza o noua instructiune de tip clasa definita si cu o lista formata din 	numele clasei si numele parintelui;
-parseVar verifica ca numele variabilei si a tipului ei incep cu o litera si nu mai e nimic in plus sau in minus, iar apoi creaza o noua instructiune de tip variabila definita si cu o lista formata din numele variabilei si tipul ei;
-parseFunc face o groaza de verificari inclusiv ale parametrilor functiei pentru a se asigura ca instructiunea este valida si mai apoi incepe sa parseze linia creand o noua instructiune de tip functie definita si cu o lista formata din valoarea returnata, clasa continatoare, numele functiei si parametrii acesteia;
	Functia interpret va primi o instructiune si un program si daca primeste NotInstruction atunci va returna acelasi program altfel in functie de tipul instructiunii va declara o functie/variabila/clasa si o va pune in Program. In timpul apelului functiei interpret se si verifica daca clasele care apar in declarari exista deja in program sau nu.
	Pentru functiile care trebuiau implementate la b) am parcurs de fiecare data programul pana am ajuns la clasa cu acelasi nume ca cel cautat (in cazul variabilelor doar in clasa Global puteau fi asa ca asta am cautat) si apoi fie am returnat direct ce trebuia, fie am apelat una din functiile de la a) pentru a gasi ce trebuie returnat.
	Task c
	Pentru acest task am facut o functie (getType) care primea un Program si o Expr si returna tipul expresiei ca pe un String sau [] daca ceva era in neregula cu expresia. Daca expresia era de tip Va atunci se cauta in Program variabila cu acelasi nume si se returna tipul ei sau, daca nu era gasita, []. Daca expresia era de tip FCall atunci se cauta in Program variabila cu acelasi nume ca cea care apela functia si apoi se returna o lista de functii cu acelasi nume pe care acea variabila le putea apela. Dupa aceea pentru intreaga lista de Expr se apela functia getType si apoi se comparau parametrii functiilor din lista originala cu cei obtinuti din lista de Expr. Daca functia apelata chiar exista atunci in lista de functii ar mai trebui sa ramana una singura, caz in care returnez tipul returnat de acea functie. Daca functia nu exista atunci lista e goala si returnez [].
	Functia infer apeleaza getType si apoi returneaza Nothing (daca primeste []) sau Just ... .
	Task d
	Mi-am definit la parsare functia parseInfer care apeleaza functia infer pentru a afla tipul variabile declarate si apoi creaza o noua instructiune de tip Inference care contine o lista formata din numele variabilei si tipul ei. La interpret se verifica daca tipul este valid si apoi se declara ca pe o variabila. Mi-am definit doua functii care imi convertesc un String intr-un arbore de tip Expr:
-getExprFromLine daca numele variabilei este urmat de un punct atunci creaza o noua instanta de FCall cu parametrii corespunzatori si apeleaza functia getExprFromParantheses pentru a obtine o lista de Expr din parametrii aflat intre paranteze;
-getExprFromParantheses transforma lista de parametri a unei functii intr-o lista de Expr. Daca da peste o variabila atunci creaza o noua instanta de tip Va si isi continua treaba altfel, daca da peste apelul altei functii care este data ca parametru, apeleaza functia getExprFromLine si apoi isi continua treaba de unde se inchid parantezele functiei;
