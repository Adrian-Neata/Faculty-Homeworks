Neata Adrian 321CB

	Pentru realizarea temei m-am folosit de 7 clase si o interfata (ICache).
	In clasa Main nu am decat functia static void main care imi citeste din fisierul de input si care imi scrie in fisierul de output rezultatele comenzii GET.
	Subscriptiile le-am definit pe toate in fisierul Premium.java. Pentru Basic si Premium am creat si un contor care sa retina numarul de subscriptii ramase si getterii si setterii pentru ele. Din convenienta am ales ca memoria cu care lucrez sa fie implementata cu obiecte de tip Premium deoarece pot accesa dupaia si celelalte clase de subscriptii din mosteniri.
	Am definit o clasa Memory care implementeaza memoria folosindu-se de un ArrayList cu obiecte de tip Premium si care are trei functii: getElement care returneaza elementul de pe pozitia index din ArrayList, searchMemory care cauta dupa nume un element in ArrayList si add care imi adauga in ArrayList obiectul introdus ca parametru pentru index == -1 sau mi-l suprascrie caz in care index reprezinta pozitia elementului cu acelasi nume din memorie care trebuie suprascris. 
	Pentru memoria de tip cache am impartit-o in trei clase cu nume sugestive: FIFOCache, LRUCache si LFUCache care implementeaza interfata ICache si mosteneste clasa Memory (pentru a se folosi de functiile searchMemory si getElement fara sa trebuiasca sa mai fie scrise o data).
	In FIFOCache am tratat memoria ca pe o coada. Functia add va sterge primul element din memorie folosindu-se de remove daca nu mai este loc in memorie si apoi va continua adaugand elementul dat ca parametru. Functia remove sterge elementul de pe pozitia data de parametrul index.
	In LRUCache am functia add care se comporta la fel ca in FIFOCache. Functia reorder este apelata de fiecare data cand apare comanda GET asupra unui obiect care se afla in cache si cauta si muta acel element la capatul ArrayList-ul (astfel la capatul listei se vor afla elementele care au fost folosite cel mai recent). Functia remove sterge elementul de pe pozitia index sau daca index == -1 imi sterge elementul de pe prima pozitie (least recently used).
	In LFUCache am creat un nou ArrayList<Integer> timestamp in care retin de cate ori a fost utilizat fiecare element din cache (elementul de pe o anumita pozitie din memoria cache corespunde cu numarul de pe exact aceeasi pozitie din timeStamp). In add adaug un element nou si un nou int cu valoare 0 in timestamp sau apelez mai intai remove daca nu mai este loc in memorie. Functia remove cauta valoarea din timestamp cea mai mica si-l sterge o data cu elementul din memorie de pe aceeasi pozitie daca index == -1 sau pur si simplu sterge elementul de pe pozitia index din memorie si din timestamp. Functia incStamp imi incrementeaza int-ul corespunzator elementului de pe pozitia index data ca parametru.
	In Cache am declarat toate cele 3 tipuri de memorie cache (FIFO, LRU si LFU) si pe cea principala apoi am implementat functiile add si get. Add imi creeaza un nou obiect de tip Premium cu valorile sale date ca parametri (nume si numar subscriptii) apoi am apelat functia de adaugare in memoria principala. Daca functie de rezultatul cautarii elementului dupa nume in memoria cache respectiva este pozitiv atunci elementul se sterge din cache. In get se returneaza un string care urmeaza a fi scris in fisierul de output in main. Elementul se adauga in memoria cache corespunzatoare daca nu se afla deja.
